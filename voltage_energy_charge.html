<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circuit Energy Flow Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow-x: hidden;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        
        .title {
            font-size: 28px;
            margin-bottom: 20px;
            text-align: center;
            background: linear-gradient(45deg, #4a90ff, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        canvas {
            border: 2px solid #333;
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(74, 144, 255, 0.2);
            background: #0a0a0a;
        }
        
        .top-controls {
            position: absolute;
            top: 80px;
            left: 200px; /* Adjust to position between speed control and info panel */
            display: flex;
            gap: 20px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .control-group h3 {
            margin: 0;
            font-size: 16px;
            color: #ccc;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 8px 16px;
            font-size: 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .battery-btn {
            background: linear-gradient(45deg, #ff8c00, #ffa500);
            color: white;
        }
        
        .bulb-btn {
            background: linear-gradient(45deg, #ffd700, #ffeb3b);
            color: black;
        }
        
        .play-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        button.active {
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .speed-control {
            position: absolute;
            top: 80px;
            left: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .speed-control h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #ccc;
        }
        
        .slider {
            width: 150px;
            height: 6px;
            border-radius: 3px;
            background: #aaa;
            outline: none;
            appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4a90ff;
            cursor: pointer;
        }
        
        .info-panel {
            position: absolute;
            top: 80px;
            right: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            min-width: 200px;
        }
        
        .info-item {
            margin: 8px 0;
            font-size: 14px;
        }

        .charge-control {
            position: absolute;
            top: 250px;
            right: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            min-width: 200px;
        }

        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .radio-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #ccc;
            font-size: 14px;
        }

        .radio-item input[type="radio"] {
            margin: 0;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #ccc;
            font-size: 14px;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #555;
        }

        .checkbox-item input[type="checkbox"] {
            margin: 0;
        }

        .magnifying-control {
            position: absolute;
            top: 400px;
            right: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            min-width: 200px;
        }
        
        .voltage-value { color: #ff8c00; }
        .current-value { color: #4a90ff; }
        .power-value { color: #ffd700; }
        
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 250px;
            font-size: 12px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="title">Circuit Energy Flow Visualization</h1>
        
        <canvas id="canvas" width="900" height="600"></canvas>
    </div>

    <div class="speed-control">
        <h3>Simulation Control</h3>
        <button class="play-btn" id="playBtn" onclick="togglePlayPause()">Pause</button>
        <div style="margin-top: 15px;">
            <h3>Electron Speed</h3>
            <input type="range" min="0.5" max="3" value="1.5" step="0.1" class="slider" id="speedSlider">
            <div id="speedValue">1.5x</div>
        </div>
    </div>

    <div class="top-controls">
        <div class="control-group">
            <h3>Batteries (6V each)</h3>
            <div class="button-group">
                <button class="battery-btn active" onclick="setBatteries(1)">1</button>
                <button class="battery-btn" onclick="setBatteries(2)">2</button>
                <button class="battery-btn" onclick="setBatteries(3)">3</button>
            </div>
        </div>
        
        <div class="control-group">
            <h3>Light Bulbs</h3>
            <div class="button-group">
                <button class="bulb-btn active" onclick="setBulbs(1)">1</button>
                <button class="bulb-btn" onclick="setBulbs(2)">2</button>
                <button class="bulb-btn" onclick="setBulbs(3)">3</button>
            </div>
        </div>
    </div>

    <div class="info-panel">
        <div class="info-item">Total Voltage: <span class="voltage-value" id="totalVoltage">6V</span></div>
        <div class="info-item">Energy per Electron: <span class="voltage-value" id="energyPerElectron">6 units</span></div>
        <div class="info-item">Energy per Bulb: <span class="power-value" id="energyPerBulb">6 units</span></div>
        <div class="info-item">Bulb Brightness: <span class="power-value" id="bulbBrightness">100%</span></div>
    </div>

    <div class="charge-control">
        <h3 style="margin: 0 0 10px 0; font-size: 14px; color: #ccc;">Charge Type:</h3>
        <div class="radio-group">
            <label class="radio-item">
                <input type="radio" name="chargeType" value="electrons" checked onchange="setChargeType('electrons')">
                Electrons (e⁻)
            </label>
            <label class="radio-item">
                <input type="radio" name="chargeType" value="positive" onchange="setChargeType('positive')">
                Positive Charges (+)
            </label>
        </div>
        <div class="checkbox-item">
            <input type="checkbox" id="showPotential" onchange="toggleShowPotential()">
            <label for="showPotential">Show Potential Values</label>
        </div>
    </div>

    <div class="magnifying-control">
        <div class="checkbox-item">
            <input type="checkbox" id="showMagnifier" onchange="toggleMagnifier()">
            <label for="showMagnifier">Show Magnifying Glass</label>
        </div>
    </div>

    <div class="instructions">
        <h3 style="margin: 0 0 10px 0; font-size: 14px;">Voltmeter Instructions:</h3>
        <div>• Drag the voltmeter body to move it</div>
        <div>• Drag the red (+) and black (-) leads independently</div>
        <div>• Place lead tips on the wire to measure voltage</div>
        <div>• Voltage = difference in energy levels between sections</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        //Magnification feature
        let showMagnifier = false;
        let magnifier = null;
        let microElectrons = [];
        let latticeAtoms = [];
        
        // Circuit parameters
        let numBatteries = 1;
        let numBulbs = 1;
        let electronSpeed = 1.5;
        let isPaused = false;
        let chargeType = 'electrons'; // 'electrons' or 'positive'
        let showPotential = false;
        
        // Circuit geometry
        const circuitRect = {
            x: 150,
            y: 150,
            width: 600,
            height: 300,
            cornerRadius: 30,
            trackWidth: 40
        };
        
        // Simulation objects
        let electrons = [];
        let energyBalls = [];
        let batteries = [];
        let bulbs = [];
        let circuitSections = [];
        let voltmeter;
        let animationId;
        let time = 0;
        let isDragging = false;
        let dragTarget = null;
        
        // Circuit Section class - represents a segment of wire between components
        class CircuitSection {
            constructor(startPos, endPos, energyLevel = 0) {
                this.startPos = startPos; // Position on circuit (0-1)
                this.endPos = endPos;
                this.energyLevel = energyLevel; // Energy balls in this section
            }
            
            contains(position) {
                // Handle wrap-around case
                if (this.startPos > this.endPos) {
                    return position >= this.startPos || position <= this.endPos;
                }
                return position >= this.startPos && position <= this.endPos;
            }
        }
        
        // Electron class
        class Electron {
            constructor() {
                this.position = 0; // 0-1 around the circuit
                this.radius = 12;
                this.lastSectionTransition = null;
            }
            
            update() {
                if (isPaused) return;
                
                const oldPosition = this.position;
                // Reverse direction for positive charges
                const direction = chargeType === 'positive' ? -1 : 1;
                this.position += direction * electronSpeed * 0.002;
                
                // Handle circuit wrap-around
                if (this.position >= 1) {
                    this.position -= 1;
                } else if (this.position < 0) {
                    this.position += 1;
                }
                
                // Check for section transitions
                this.checkSectionTransition(oldPosition);
            }
            
            checkSectionTransition(oldPosition) {
                const oldSection = this.getCurrentSection(oldPosition);
                const newSection = this.getCurrentSection(this.position);
                
                // Only process if we've actually changed sections
                if (oldSection !== newSection && newSection !== this.lastSectionTransition) {
                    this.lastSectionTransition = newSection;
                    
                    const direction = chargeType === 'positive' ? -1 : 1;
                    
                    // Check if we're passing a battery
                    batteries.forEach((battery, index) => {
                        const crossedBattery = (direction > 0) ? 
                            (oldPosition < battery.position && this.position >= battery.position) || 
                            (oldPosition > 0.9 && this.position < 0.1 && battery.position < 0.1) :
                            (oldPosition > battery.position && this.position <= battery.position) ||
                            (oldPosition < 0.1 && this.position > 0.9 && battery.position > 0.9);
                            
                        if (crossedBattery) {
                            // Create visual energy transfer from battery
                            const batteryCoords = battery.getCoordinates();
                            const chargeCoords = this.getCoordinates();
                            for (let i = 0; i < 6; i++) {
                                setTimeout(() => {
                                    energyBalls.push(new EnergyBall(
                                        batteryCoords.x, batteryCoords.y + 30,
                                        chargeCoords.x, chargeCoords.y, 'receive'
                                    ));
                                }, i * 50);
                            }
                        }
                    });
                    
                    // Check if we're passing a bulb
                    bulbs.forEach((bulb, index) => {
                        const crossedBulb = (direction > 0) ? 
                            (oldPosition < bulb.position && this.position >= bulb.position) ||
                            (oldPosition > 0.9 && this.position < 0.1 && bulb.position < 0.1) :
                            (oldPosition > bulb.position && this.position <= bulb.position) ||
                            (oldPosition < 0.1 && this.position > 0.9 && bulb.position > 0.9);
                            
                        if (crossedBulb) {
                            const energyToGive = Math.floor((numBatteries * 6) / numBulbs);
                            
                            // Create visual energy transfer to bulb
                            const chargeCoords = this.getCoordinates();
                            const bulbCoords = bulb.getCoordinates();
                            for (let i = 0; i < energyToGive; i++) {
                                setTimeout(() => {
                                    energyBalls.push(new EnergyBall(
                                        chargeCoords.x, chargeCoords.y,
                                        bulbCoords.x, bulbCoords.y, 'give'
                                    ));
                                    bulb.receiveEnergy();
                                }, i * 50);
                            }
                        }
                    });
                }
            }
            
            getCurrentSection(position) {
                for (let section of circuitSections) {
                    if (section.contains(position)) {
                        return section;
                    }
                }
                return null;
            }
            
            getEnergyCount() {
                const section = this.getCurrentSection(this.position);
                return section ? section.energyLevel : 0;
            }
            
            getCoordinates() {
                const perimeter = 2 * (circuitRect.width + circuitRect.height);
                const distance = this.position * perimeter;
                
                let x, y;
                
                if (distance <= circuitRect.width) {
                    // Top edge
                    x = circuitRect.x + distance;
                    y = circuitRect.y;
                } else if (distance <= circuitRect.width + circuitRect.height) {
                    // Right edge
                    x = circuitRect.x + circuitRect.width;
                    y = circuitRect.y + (distance - circuitRect.width);
                } else if (distance <= 2 * circuitRect.width + circuitRect.height) {
                    // Bottom edge
                    x = circuitRect.x + circuitRect.width - (distance - circuitRect.width - circuitRect.height);
                    y = circuitRect.y + circuitRect.height;
                } else {
                    // Left edge
                    x = circuitRect.x;
                    y = circuitRect.y + circuitRect.height - (distance - 2 * circuitRect.width - circuitRect.height);
                }
                
                return { x, y };
            }
            
            draw() {
                const coords = this.getCoordinates();
                const energyCount = this.getEnergyCount();
                
                // Different colors and symbols based on charge type
                const isPositive = chargeType === 'positive';
                
                // Draw charge particle
                ctx.beginPath();
                ctx.arc(coords.x, coords.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = isPositive ? '#FF6B6B' : '#87CEEB'; // Red for positive, blue for electrons
                ctx.fill();
                ctx.strokeStyle = isPositive ? '#CC0000' : '#4682B4';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw charge sign
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(isPositive ? '+' : '-', coords.x, coords.y + 6);
                
                // Draw energy balls (same for both charge types)
                for (let i = 0; i < energyCount; i++) {
                    const angle = (i / 18) * Math.PI * 2;
                    const orbitalRadius = this.radius + 8;
                    const energyX = coords.x + Math.cos(angle + time * 0.05) * orbitalRadius;
                    const energyY = coords.y + Math.sin(angle + time * 0.05) * orbitalRadius;
                    
                    ctx.beginPath();
                    ctx.arc(energyX, energyY, 3, 0, Math.PI * 2);
                    ctx.fillStyle = '#FF4444';
                    ctx.fill();
                }
            }
        }
        
        // Energy ball animation class
        class EnergyBall {
            constructor(startX, startY, endX, endY, type) {
                this.startX = startX;
                this.startY = startY;
                this.endX = endX;
                this.endY = endY;
                this.x = startX;
                this.y = startY;
                this.progress = 0;
                this.type = type;
                this.life = 1.0;
            }
            
            update() {
                if (isPaused) return true;
                
                this.progress += 0.05;
                
                const t = Math.min(this.progress, 1);
                this.x = this.startX + (this.endX - this.startX) * t;
                this.y = this.startY + (this.endY - this.startY) * t;
                
                if (this.progress > 1) {
                    this.life -= 0.05;
                }
                
                return this.life > 0;
            }
            
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 68, 68, ${this.life})`;
                ctx.fill();
            }
        }
        
        // Battery class
        class Battery {
            constructor(position) {
                this.position = position;
                this.width = 40;
                this.height = 60;
            }
            
            draw() {
                const coords = this.getCoordinates();
                
                // Draw battery body
                ctx.fillStyle = '#333';
                ctx.fillRect(coords.x - this.width/2, coords.y - this.height/2, this.width, this.height);
                
                // Draw positive terminal (orange half)
                ctx.fillStyle = '#FF8C00';
                ctx.fillRect(coords.x - this.width/2, coords.y - this.height/2, this.width/2, this.height);
                
                // Draw negative terminal (black half)
                ctx.fillStyle = '#000';
                ctx.fillRect(coords.x, coords.y - this.height/2, this.width/2, this.height);
                
                // Draw terminals
                ctx.fillStyle = 'white';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('+', coords.x - this.width/4, coords.y + 7);
                ctx.fillText('-', coords.x + this.width/4, coords.y + 7);
                
                // Draw border
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.strokeRect(coords.x - this.width/2, coords.y - this.height/2, this.width, this.height);
            }
            
            getCoordinates() {
                const perimeter = 2 * (circuitRect.width + circuitRect.height);
                const distance = this.position * perimeter;
                
                return {
                    x: circuitRect.x + distance,
                    y: circuitRect.y - 30
                };
            }
        }
        
        // Bulb class
        class Bulb {
            constructor(position) {
                this.position = position;
                this.brightness = 0;
                this.energyReceived = 0;
                this.radius = 20;
            }
            
            receiveEnergy() {
                this.energyReceived++;
                this.brightness = Math.min(1, this.energyReceived / 10);
            }
            
            update() {
                if (!isPaused) {
                    this.energyReceived *= 0.95; // Gradual fade
                    this.brightness = Math.min(1, this.energyReceived / 5);
                }
            }
            
            draw() {
                const coords = this.getCoordinates();
                
                // Draw light effect FIRST (so it appears behind the bulb)
                if (this.brightness > 0) {
                    // Multiple light layers for better effect
                    for (let i = 3; i >= 0; i--) {
                        const lightRadius = this.radius + (i * 15 * this.brightness);
                        const alpha = Math.max(0, this.brightness - (i * 0.2));
                        
                        ctx.beginPath();
                        ctx.arc(coords.x, coords.y, lightRadius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 0, ${alpha * 0.3})`;
                        ctx.fill();
                    }
                }
                
                // Draw rectangular base
                const baseWidth = 20;
                const baseHeight = 15;
                ctx.fillStyle = '#444';
                ctx.fillRect(coords.x - baseWidth/2, coords.y + this.radius - 5, baseWidth, baseHeight);
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.strokeRect(coords.x - baseWidth/2, coords.y + this.radius - 5, baseWidth, baseHeight);
                
                // Draw bulb circle (glass)
                ctx.beginPath();
                ctx.arc(coords.x, coords.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.brightness > 0 
                    ? `rgba(255, 255, 200, ${0.3 + this.brightness * 0.5})` 
                    : 'rgba(200, 200, 200, 0.3)';
                ctx.fill();
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw filament inside
                ctx.strokeStyle = this.brightness > 0.1 ? '#FFD700' : '#666';
                ctx.lineWidth = this.brightness > 0.1 ? 2 : 1;
                ctx.beginPath();
                // Draw a zigzag filament
                const filamentPoints = 5;
                for (let i = 0; i <= filamentPoints; i++) {
                    const yPos = coords.y - 10 + (20 * i / filamentPoints);
                    const xPos = coords.x + (i % 2 === 0 ? -5 : 5);
                    if (i === 0) {
                        ctx.moveTo(xPos, yPos);
                    } else {
                        ctx.lineTo(xPos, yPos);
                    }
                }
                ctx.stroke();
                
                // Bright center when very lit
                if (this.brightness > 0.5) {
                    ctx.beginPath();
                    ctx.arc(coords.x, coords.y, this.radius * 0.6, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.brightness * 0.4})`;
                    ctx.fill();
                }
            }
            
            getCoordinates() {
                const perimeter = 2 * (circuitRect.width + circuitRect.height);
                const bottomStart = (circuitRect.width + circuitRect.height) / perimeter;
                const bottomEnd = (circuitRect.width + circuitRect.height + circuitRect.width) / perimeter;
                
                // Position is already normalized between bottomStart and bottomEnd
                const distance = this.position * perimeter;
                
                return {
                    x: circuitRect.x + circuitRect.width - (distance - circuitRect.width - circuitRect.height),
                    y: circuitRect.y + circuitRect.height + 40
                };
            }
        }
        
        // Voltmeter Lead class
        class VoltmeterLead {
            constructor(x, y, color, label) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.label = label;
                this.radius = 8;
                this.isDragging = false;
                this.connectedSection = null;
            }
            
            update() {
                // Check if lead tip is on the circuit wire
                this.connectedSection = this.getConnectedSection();
            }
            
            getConnectedSection() {
                // Check if the lead tip is close enough to the circuit wire
                const tolerance = 25;
                
                // Get circuit path points
                const { x, y, width, height } = circuitRect;
                
                // Check top edge
                if (Math.abs(this.y - y) < tolerance && this.x >= x && this.x <= x + width) {
                    const position = (this.x - x) / (2 * (width + height));
                    return this.getSectionAtPosition(position);
                }
                
                // Check right edge
                if (Math.abs(this.x - (x + width)) < tolerance && this.y >= y && this.y <= y + height) {
                    const position = (width + (this.y - y)) / (2 * (width + height));
                    return this.getSectionAtPosition(position);
                }
                
                // Check bottom edge
                if (Math.abs(this.y - (y + height)) < tolerance && this.x >= x && this.x <= x + width) {
                    const position = (width + height + (x + width - this.x)) / (2 * (width + height));
                    return this.getSectionAtPosition(position);
                }
                
                // Check left edge
                if (Math.abs(this.x - x) < tolerance && this.y >= y && this.y <= y + height) {
                    const position = (2 * width + height + (y + height - this.y)) / (2 * (width + height));
                    return this.getSectionAtPosition(position);
                }
                
                return null;
            }
            
            getSectionAtPosition(position) {
                // Normalize position to 0-1
                if (position >= 1) position -= 1;
                if (position < 0) position += 1;
                
                for (let section of circuitSections) {
                    if (section.contains(position)) {
                        return section;
                    }
                }
                return null;
            }
            
            draw() {
                // Draw lead wire to voltmeter
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(voltmeter.x + (this.label === '+' ? 40 : -40), voltmeter.y + 20);
                ctx.lineTo(this.x, this.y);
                ctx.stroke();
                
                // Draw lead tip
                ctx.beginPath();
                ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#FFFFFF';
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw connection indicator if connected
                if (this.connectedSection) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI * 2);
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return dx * dx + dy * dy <= (this.radius + 5) * (this.radius + 5);
            }
        }
        
        // Voltmeter class
        class Voltmeter {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 120;
                this.height = 80;
                this.positiveLead = new VoltmeterLead(x + 60, y + 60, '#FF0000', '+');
                this.negativeLead = new VoltmeterLead(x - 60, y + 60, '#000000', '-');
            }
            
            update() {
                this.positiveLead.update();
                this.negativeLead.update();
            }
            
            getVoltageReading() {
                if (this.positiveLead.connectedSection && this.negativeLead.connectedSection) {
                    const positiveEnergy = this.positiveLead.connectedSection.energyLevel;
                    const negativeEnergy = this.negativeLead.connectedSection.energyLevel;
                    return Math.abs(positiveEnergy - negativeEnergy);
                }
                return 0;
            }
            
            draw() {
                // Draw voltmeter body
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                
                // Draw display screen
                const screenWidth = 80;
                const screenHeight = 30;
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x - screenWidth/2, this.y - screenHeight/2 - 10, screenWidth, screenHeight);
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x - screenWidth/2, this.y - screenHeight/2 - 10, screenWidth, screenHeight);
                
                // Draw voltage reading
                const voltage = this.getVoltageReading();
                ctx.fillStyle = '#00FF00';
                ctx.font = 'bold 16px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${voltage.toFixed(1)}V`, this.x, this.y - 5);
                
                // Draw "VOLTMETER" label
                ctx.fillStyle = '#ccc';
                ctx.font = 'bold 10px Arial';
                ctx.fillText('VOLTMETER', this.x, this.y + 25);
                
                // Draw lead connection points
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.arc(this.x + 35, this.y + 20, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('+', this.x + 35, this.y + 24);
                
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(this.x - 35, this.y + 20, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.fillStyle = 'white';
                ctx.fillText('-', this.x - 35, this.y + 24);
                
                // Draw leads
                this.positiveLead.draw();
                this.negativeLead.draw();
            }
            
            contains(x, y) {
                return x >= this.x - this.width/2 && x <= this.x + this.width/2 &&
                       y >= this.y - this.height/2 && y <= this.y + this.height/2;
            }
        }

        // Micro Electron class for realistic physics
        class MicroElectron {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2; // Reduced initial random velocity
                this.vy = (Math.random() - 0.5) * 2;
                this.radius = 1.5;
                this.driftSpeed = 0.2; // Increased drift speed
            }
            
            update(driftDirection) {
                // Only update if magnifier is over wire
                if (!magnifier.isOverWire()) {
                    return;
                }
                
                // Increased drift bias and reduced random motion
                const driftX = Math.cos(driftDirection) * this.driftSpeed * 3;
                const driftY = Math.sin(driftDirection) * this.driftSpeed * 3;
                
                // Update position with thermal motion + stronger drift
                this.x += this.vx * 0.7 + driftX;
                this.y += this.vy * 0.7 + driftY;
                
                // Check collision with lattice atoms
                for (let atom of latticeAtoms) {
                    const dx = this.x - atom.x;
                    const dy = this.y - atom.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < atom.radius + this.radius) {
                        // Collision! Scatter but maintain some drift bias
                        const angle = Math.random() * Math.PI * 2;
                        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy) * 0.8; // Reduce speed on collision
                        this.vx = Math.cos(angle) * speed + driftX * 0.5; // Keep some drift
                        this.vy = Math.sin(angle) * speed + driftY * 0.5;
                        
                        // Move away from atom
                        const pushDistance = atom.radius + this.radius + 2;
                        this.x = atom.x + (dx / distance) * pushDistance;
                        this.y = atom.y + (dy / distance) * pushDistance;
                    }
                }
                
                // Wrap around extended boundaries (larger than visible area)
                const bounds = 100;
                if (this.x < -bounds) this.x = bounds;
                if (this.x > bounds) this.x = -bounds;
                if (this.y < -bounds) this.y = bounds;
                if (this.y > bounds) this.y = -bounds;
                
                // Reduced random velocity changes
                this.vx += (Math.random() - 0.5) * 0.1; // Reduced from 0.2
                this.vy += (Math.random() - 0.5) * 0.1;
                
                // Add slight bias toward drift direction
                this.vx += driftX * 0.1;
                this.vy += driftY * 0.1;
                
                // Limit maximum speed
                const maxSpeed = 3; // Reduced from 6
                const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (currentSpeed > maxSpeed) {
                    this.vx = (this.vx / currentSpeed) * maxSpeed;
                    this.vy = (this.vy / currentSpeed) * maxSpeed;
                }
            }
            
            draw(centerX, centerY) {
                ctx.beginPath();
                ctx.arc(centerX + this.x, centerY + this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#87CEEB';
                ctx.fill();
                ctx.strokeStyle = '#4682B4';
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }
        }

        // Lattice Atom class
        class LatticeAtom {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 4;
            }
            
            draw(centerX, centerY) {
                ctx.beginPath();
                ctx.arc(centerX + this.x, centerY + this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#C0C0C0'; // Silver metallic color
                ctx.fill();
                ctx.strokeStyle = '#A0A0A0';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // Magnifying Glass class
        class MagnifyingGlass {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 80;
                this.handleLength = 40;
                this.isDragging = false;
            }
            
            initializeLatticeAndElectrons() {
                latticeAtoms = [];
                microElectrons = [];
                
                // Create extended lattice structure (larger than visible area for smooth transitions)
                const spacing = 12;
                for (let x = -120; x <= 120; x += spacing) {
                    for (let y = -120; y <= 120; y += spacing) {
                        latticeAtoms.push(new LatticeAtom(x, y));
                    }
                }
                
                // Create more micro electrons with better distribution
                for (let i = 0; i < 35; i++) {
                    const x = (Math.random() - 0.5) * 200;
                    const y = (Math.random() - 0.5) * 200;
                    microElectrons.push(new MicroElectron(x, y));
                }
            }

            isOverWire() {
                const tolerance = this.radius + 20; // Extra tolerance for smooth transitions
                const { x, y, width, height } = circuitRect;
                
                // Check if magnifier overlaps with any part of the circuit wire
                // Top edge
                if (this.y >= y - tolerance && this.y <= y + tolerance && 
                    this.x >= x - tolerance && this.x <= x + width + tolerance) {
                    return true;
                }
                
                // Right edge
                if (this.x >= x + width - tolerance && this.x <= x + width + tolerance && 
                    this.y >= y - tolerance && this.y <= y + height + tolerance) {
                    return true;
                }
                
                // Bottom edge
                if (this.y >= y + height - tolerance && this.y <= y + height + tolerance && 
                    this.x >= x - tolerance && this.x <= x + width + tolerance) {
                    return true;
                }
                
                // Left edge
                if (this.x >= x - tolerance && this.x <= x + tolerance && 
                    this.y >= y - tolerance && this.y <= y + height + tolerance) {
                    return true;
                }
                
                return false;
            }
            
            getCurrentDirection() {
                if (!this.isOverWire()) {
                    return 0; // Default direction if not over wire
                }
                
                const { x, y, width, height } = circuitRect;
                const tolerance = this.radius + 20;
                
                // Determine which edge we're closest to and return appropriate direction
                // Top edge - move right
                if (this.y >= y - tolerance && this.y <= y + tolerance && 
                    this.x >= x - tolerance && this.x <= x + width + tolerance) {
                    return chargeType === 'positive' ? Math.PI : 0; // Right for electrons, left for positive
                }
                
                // Right edge - move down  
                if (this.x >= x + width - tolerance && this.x <= x + width + tolerance && 
                    this.y >= y - tolerance && this.y <= y + height + tolerance) {
                    return chargeType === 'positive' ? -Math.PI/2 : Math.PI/2; // Down for electrons, up for positive
                }
                
                // Bottom edge - move left
                if (this.y >= y + height - tolerance && this.y <= y + height + tolerance && 
                    this.x >= x - tolerance && this.x <= x + width + tolerance) {
                    return chargeType === 'positive' ? 0 : Math.PI; // Left for electrons, right for positive
                }
                
                // Left edge - move up
                if (this.x >= x - tolerance && this.x <= x + tolerance && 
                    this.y >= y - tolerance && this.y <= y + height + tolerance) {
                    return chargeType === 'positive' ? Math.PI/2 : -Math.PI/2; // Up for electrons, down for positive
                }
                
                return 0; // Default fallback
            }
            
            update() {
                if (!showMagnifier) return;
                
                // Check if we need to initialize or clear lattice based on wire position
                const overWire = this.isOverWire();
                
                if (overWire && (latticeAtoms.length === 0 || microElectrons.length === 0)) {
                    // We're over wire but don't have lattice - initialize it
                    this.initializeLatticeAndElectrons();
                } else if (!overWire && (latticeAtoms.length > 0 || microElectrons.length > 0)) {
                    // We're not over wire but have lattice - clear it
                    latticeAtoms = [];
                    microElectrons = [];
                }
                
                // Update micro electrons if they exist
                if (overWire && microElectrons.length > 0) {
                    const direction = this.getCurrentDirection();
                    microElectrons.forEach(electron => {
                        electron.update(direction);
                    });
                }
            }
            
            draw() {
                if (!showMagnifier) return;
                
                // Save context for clipping
                ctx.save();
                
                // Create circular clipping path
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.clip();
                
                // Fill magnifier background
                ctx.fillStyle = '#1a1a1a';
                ctx.fill();
                
                // Only draw lattice and electrons if over wire
                if (this.isOverWire()) {
                    // Draw lattice atoms (only those visible in the magnifier)
                    latticeAtoms.forEach(atom => {
                        const screenX = this.x + atom.x;
                        const screenY = this.y + atom.y;
                        const dx = screenX - this.x;
                        const dy = screenY - this.y;
                        if (dx * dx + dy * dy <= this.radius * this.radius) {
                            atom.draw(this.x, this.y);
                        }
                    });
                    
                    // Draw micro electrons (only those visible)
                    microElectrons.forEach(electron => {
                        const screenX = this.x + electron.x;
                        const screenY = this.y + electron.y;
                        const dx = screenX - this.x;
                        const dy = screenY - this.y;
                        if (dx * dx + dy * dy <= this.radius * this.radius) {
                            electron.draw(this.x, this.y);
                        }
                    });
                }
                
                // Restore context
                ctx.restore();
                
                // Draw magnifier border and handle
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 4;
                ctx.stroke();
                
                // Draw handle
                const handleX = this.x + this.radius * 0.7;
                const handleY = this.y + this.radius * 0.7;
                ctx.beginPath();
                ctx.moveTo(this.x + this.radius * 0.5, this.y + this.radius * 0.5);
                ctx.lineTo(handleX, handleY);
                ctx.lineWidth = 6;
                ctx.strokeStyle = '#444';
                ctx.stroke();
                
                // Draw glass reflection effect
                ctx.beginPath();
                ctx.arc(this.x - 20, this.y - 20, 15, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fill();
            }
            
            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return dx * dx + dy * dy <= this.radius * this.radius;
            }
        }
        
        function drawCircuit() {
            const { x, y, width, height, cornerRadius, trackWidth } = circuitRect;
            
            // Draw wire track
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = trackWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            ctx.roundRect(x, y, width, height, cornerRadius);
            ctx.stroke();
            
            // Draw inner track
            ctx.strokeStyle = '#A0522D';
            ctx.lineWidth = trackWidth - 10;
            ctx.stroke();
        }

        function drawSectionEnergyLabels() {
            if (!circuitSections || circuitSections.length === 0) return;
            
            ctx.fillStyle = '#FFFF00'; // Yellow text for visibility
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            
            circuitSections.forEach((section, index) => {
                // Calculate midpoint of this section
                let midPosition = (section.startPos + section.endPos) / 2;
                
                // Handle wrap-around case
                if (section.startPos > section.endPos) {
                    midPosition = section.startPos + (1 - section.startPos + section.endPos) / 2;
                    if (midPosition >= 1) midPosition -= 1;
                }
                
                // Convert position to coordinates (same logic as electron coordinates)
                const perimeter = 2 * (circuitRect.width + circuitRect.height);
                const distance = midPosition * perimeter;
                
                let x, y;
                
                if (distance <= circuitRect.width) {
                    // Top edge
                    x = circuitRect.x + distance;
                    y = circuitRect.y - 15; // Above the wire
                } else if (distance <= circuitRect.width + circuitRect.height) {
                    // Right edge
                    x = circuitRect.x + circuitRect.width + 25; // Right of the wire
                    y = circuitRect.y + (distance - circuitRect.width);
                } else if (distance <= 2 * circuitRect.width + circuitRect.height) {
                    // Bottom edge
                    x = circuitRect.x + circuitRect.width - (distance - circuitRect.width - circuitRect.height);
                    y = circuitRect.y + circuitRect.height + 25; // Below the wire
                } else {
                    // Left edge
                    x = circuitRect.x - 25; // Left of the wire
                    y = circuitRect.y + circuitRect.height - (distance - 2 * circuitRect.width - circuitRect.height);
                }
                
                // Draw the energy level
                ctx.fillText(`${section.energyLevel}V`, x, y);
            });
        }

        function toggleShowPotential() {
            showPotential = document.getElementById('showPotential').checked;
        }

        function toggleMagnifier() {
            showMagnifier = document.getElementById('showMagnifier').checked;
            if (showMagnifier && !magnifier) {
                magnifier = new MagnifyingGlass(500, 300);
                magnifier.initializeLatticeAndElectrons();
            }
        }
        
        function createCircuitSections() {
            circuitSections = [];
            
            // Collect all component positions and sort them
            const components = [];
            
            // Add batteries (on top edge)
            batteries.forEach((battery, i) => {
                components.push({
                    position: battery.position,
                    type: 'battery',
                    index: i
                });
            });
            
            // Add bulbs (on bottom edge)
            bulbs.forEach((bulb, i) => {
                components.push({
                    position: bulb.position,
                    type: 'bulb',
                    index: i
                });
            });
            
            // Sort components by position
            components.sort((a, b) => a.position - b.position);
            
            // Create sections between components
            for (let i = 0; i < components.length; i++) {
                const current = components[i];
                const next = components[(i + 1) % components.length];
                
                let energyLevel = 0;
                
                // Calculate energy levels as if for electrons first
                let batteriesEncountered = 0;
                let bulbsEncountered = 0;
                
                // Count batteries and bulbs before this section
                for (let j = 0; j <= i; j++) {
                    if (components[j].type === 'battery') {
                        batteriesEncountered++;
                    } else if (components[j].type === 'bulb') {
                        bulbsEncountered++;
                    }
                }
                
                // Calculate energy: batteries add 6 each, bulbs consume proportionally
                energyLevel = batteriesEncountered * 6 - bulbsEncountered * Math.floor((numBatteries * 6) / numBulbs);
                energyLevel = Math.max(0, energyLevel); // Can't be negative
                
                const section = new CircuitSection(
                    current.position,
                    next.position,
                    energyLevel
                );
                
                circuitSections.push(section);
            }
            
            // If positive charges, reverse and rotate the energy levels
            if (chargeType !== 'electrons') {
                const energyLevels = circuitSections.map(section => section.energyLevel);
                energyLevels.reverse();
                
                // Rotate by (numBatteries - 1) positions the other way
                const rotateBy = numBatteries - 1;
                for (let i = 0; i < rotateBy; i++) {
                    energyLevels.unshift(energyLevels.pop());  // Changed from push/shift to unshift/pop
                }
                
                circuitSections.forEach((section, i) => {
                    section.energyLevel = energyLevels[i];
                });
            }
        }
        
        function setupCircuit() {
            // Clear existing objects
            electrons = [];
            batteries = [];
            bulbs = [];
            circuitSections = [];
            
            // Initialize voltmeter if it doesn't exist
            if (!voltmeter) {
                voltmeter = new Voltmeter(300, 300);
            }
            
            // Create batteries along the top - evenly spaced
            for (let i = 0; i < numBatteries; i++) {
                const spacing = circuitRect.width / (numBatteries + 1);
                const xPosition = spacing * (i + 1);
                const position = xPosition / (2 * (circuitRect.width + circuitRect.height));
                batteries.push(new Battery(position));
            }
            
            // Create bulbs along the bottom
            const perimeter = 2 * (circuitRect.width + circuitRect.height);
            const bottomStart = (circuitRect.width + circuitRect.height) / perimeter;
            const bottomLength = circuitRect.width / perimeter;
            
            for (let i = 0; i < numBulbs; i++) {
                const spacing = 1 / (numBulbs + 1);
                const t = spacing * (i + 1);
                const position = bottomStart + t * bottomLength;
                bulbs.push(new Bulb(position));
            }
            
            // Create circuit sections based on component positions
            createCircuitSections();
            
            // Create electrons (spaced around the circuit)
            const numElectrons = 6;
            for (let i = 0; i < numElectrons; i++) {
                const electron = new Electron();
                electron.position = i / numElectrons;
                electrons.push(electron);
            }

            // Initialize magnifier if needed
            if (showMagnifier && !magnifier) {
                magnifier = new MagnifyingGlass(300, 300);
                magnifier.initializeLatticeAndElectrons();
            }
        }
        
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw circuit
            drawCircuit();

            // Draw section energy labels if enabled
            if (showPotential) {
                drawSectionEnergyLabels();
            }
            
            // Update and draw batteries
            batteries.forEach(battery => battery.draw());
            
            // Update and draw bulbs
            bulbs.forEach(bulb => {
                bulb.update();
                bulb.draw();
            });
            
            // Update and draw electrons
            electrons.forEach(electron => {
                electron.update();
                electron.draw();
            });
            
            // Update and draw energy balls
            energyBalls = energyBalls.filter(ball => {
                const alive = ball.update();
                if (alive) ball.draw();
                return alive;
            });
            
            // Update and draw voltmeter
            if (voltmeter) {
                voltmeter.update();
                voltmeter.draw();
            }

            // Update and draw magnifying glass
            if (magnifier && showMagnifier) {
                magnifier.update();
                magnifier.draw();
            }
            
            updateInfo();
            
            if (!isPaused) {
                time++;
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        function setBatteries(num) {
            numBatteries = num;
            setupCircuit();
            updateButtonStates('battery', num);
        }
        
        function setBulbs(num) {
            numBulbs = num;
            setupCircuit();
            updateButtonStates('bulb', num);
        }

        function setChargeType(type) {
            chargeType = type;
            // Reset the simulation with new charge type
            setupCircuit();
        }
        
        function updateButtonStates(type, activeNum) {
            const buttons = document.querySelectorAll(type === 'battery' ? '.battery-btn' : '.bulb-btn');
            buttons.forEach((btn, index) => {
                btn.classList.toggle('active', index + 1 === activeNum);
            });
        }
        
        function updateInfo() {
            const totalVoltage = numBatteries * 6;
            const energyPerElectron = totalVoltage;
            const energyPerBulb = totalVoltage / numBulbs;
            const brightness = Math.min(100, (energyPerBulb / 6) * 100);
            
            const chargeLabel = chargeType === 'positive' ? 'Positive Charge' : 'Electron';
            
            document.getElementById('totalVoltage').textContent = `${totalVoltage}V`;
            document.getElementById('energyPerElectron').textContent = `${energyPerElectron} units`;
            document.getElementById('energyPerBulb').textContent = `${energyPerBulb.toFixed(1)} units`;
            document.getElementById('bulbBrightness').textContent = `${brightness.toFixed(0)}%`;
        }
        
        function togglePlayPause() {
            isPaused = !isPaused;
            const playBtn = document.getElementById('playBtn');
            playBtn.textContent = isPaused ? 'Play' : 'Pause';
        }
        
        // Speed control
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            electronSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = `${electronSpeed}x`;
        });
        
        // Mouse event handlers for dragging
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Check if clicking on voltmeter leads first (they have priority)
            if (voltmeter.positiveLead.contains(mouseX, mouseY)) {
                isDragging = true;
                dragTarget = voltmeter.positiveLead;
                canvas.style.cursor = 'grabbing';
            } else if (voltmeter.negativeLead.contains(mouseX, mouseY)) {
                isDragging = true;
                dragTarget = voltmeter.negativeLead;
                canvas.style.cursor = 'grabbing';
            } else if (voltmeter.contains(mouseX, mouseY)) {
                isDragging = true;
                dragTarget = voltmeter;
                canvas.style.cursor = 'grabbing';
            } else if (magnifier && magnifier.contains(mouseX, mouseY)) {
                isDragging = true;
                dragTarget = magnifier;
                canvas.style.cursor = 'grabbing';
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            if (isDragging && dragTarget) {
                if (dragTarget === voltmeter) {
                    // Move voltmeter body
                    voltmeter.x = mouseX;
                    voltmeter.y = mouseY;
                } else if (dragTarget === magnifier) {
                    // Move magnifying glass
                    magnifier.x = mouseX;
                    magnifier.y = mouseY;
                } else {
                    // Move individual lead
                    dragTarget.x = mouseX;
                    dragTarget.y = mouseY;
                }
            } else {
                // Set cursor based on what's under the mouse
                if (voltmeter.positiveLead.contains(mouseX, mouseY) || 
                    voltmeter.negativeLead.contains(mouseX, mouseY) || 
                    voltmeter.contains(mouseX, mouseY) ||
                    (magnifier && magnifier.contains(mouseX, mouseY))) {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.style.cursor = 'default';
                }
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            dragTarget = null;
            canvas.style.cursor = 'default';
        });
        
        // Handle mouse leave to stop dragging
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            dragTarget = null;
            canvas.style.cursor = 'default';
        });
        
        // Initialize simulation
        setupCircuit();
        animate();
    </script>
</body>
</html>